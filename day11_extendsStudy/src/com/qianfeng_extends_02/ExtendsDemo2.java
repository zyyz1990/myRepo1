package com.qianfeng_extends_02;

/*
 * 注意事项:
 * 		子类的构造方法默认访问父类的无参,
 * 						那么如果父类中没有提供无参构造方法?会怎么办
 * 
 * 会编译报错,因为父类有存在有参构造方法,系统不会提供无参的,又由于子类的所有构造
 * 方法默认访问父类的无参,所以报错了!
 * 
 * 如何解决呢?
 * 	 1)手动给出父类的无参构造方法
 * 	 2)可以让子类的所有构造方法,默认访问父类的有参
 * 		在子类的构造方法的第一句话:super(xxx)
 * 	 子类中所有构造方法的一个只要能够让父类初始化即可!
 * 		
 * 	 3)通过子类的有参构造方法,访问this()本类的无参构造方法,在通过本类的无参构造方法
 * 访问父类的有参构造(让父类先进行初始化)
 * 
 * 
 * 开发中:
 * 		子类的无参访问父类的无参....
 * 	    子类的有参访问父类的有参....
 * 
 * 
 * 面试题:
 * 	this和super的区别?
 * 	this:代表当前类的对象地址值引用
 *  super:代表父类的空间标识(父类对象的地址值引用)
 *  
 *  访问的区别
 *  		this.成员变量;访问的当期类的成员变量
 *  		super.成员变量;访问的父类的成员变量
 *  
 *  		this.成员方法名() ;访问的是否当前类的成员方法
 *  		super.成员方法名() ;访问的是父类的成员方法
 *  
 *  		this() :访问的是本类无参构造方法
 * 			this(xxx):访问的本类的有参构造方法
 * 
 * 			super():访问的是父类的无参构造方法
 * 			super(xxx):访问的父类的有参构造方法
 * */

//父类
class Fu2{
	/*
	public Fu2() {
		
	}
	*/
	
	public Fu2(String name) {
		System.out.println("这是Fu的有参构造方法...");
	}
	
	
}

//子类
class Zi2 extends Fu2{
	
	//子类的无参构造方法
	public Zi2() {
		//super("随便给") ; //让子类的构造方法直接访问父类的有参
		
		super("随便给") ;
		System.out.println("这是Zi的无参构造方法...");
		
		
	}
	
	//子类的有参构造方法
	public Zi2(String name) {
		//super("随便给") ;
		
		this() ;  //让当前子类的有参构造先访问本类的无参构造方法
		System.out.println("这是Zi的有参构造方法...");
	}
}

//测试类
public class ExtendsDemo2 {

	public static void main(String[] args) {
		//创建子类对象
		Zi2 zi = new Zi2() ;
		System.out.println("-----------------------");
		Zi2 zi2 = new Zi2("高圆圆") ;
	}
}
